name: "00 - Manager Orchestrator"

on:
  schedule:
    # Run every hour
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      force_assign:
        description: 'Force task assignment even if budget exhausted'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    outputs:
      tasks_assigned: ${{ steps.assign.outputs.tasks }}
      budget_remaining: ${{ steps.budget.outputs.remaining }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate secret accessibility
        id: secrets
        run: |
          echo "üîê Validating secret accessibility..."
          
          # Check if API keys are accessible (without revealing them)
          OPENAI_AVAILABLE="false"
          ANTHROPIC_AVAILABLE="false"
          DISCORD_AVAILABLE="false"
          
          if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
            OPENAI_AVAILABLE="true"
            echo "‚úÖ OPENAI_API_KEY is accessible"
          else
            echo "‚ö†Ô∏è OPENAI_API_KEY is not configured"
          fi
          
          if [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            ANTHROPIC_AVAILABLE="true"
            echo "‚úÖ ANTHROPIC_API_KEY is accessible"
          else
            echo "‚ö†Ô∏è ANTHROPIC_API_KEY is not configured"
          fi
          
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            DISCORD_AVAILABLE="true"
            echo "‚úÖ DISCORD_WEBHOOK_URL is accessible"
          else
            echo "‚ö†Ô∏è DISCORD_WEBHOOK_URL is not configured"
          fi
          
          echo "openai_available=$OPENAI_AVAILABLE" >> $GITHUB_OUTPUT
          echo "anthropic_available=$ANTHROPIC_AVAILABLE" >> $GITHUB_OUTPUT
          echo "discord_available=$DISCORD_AVAILABLE" >> $GITHUB_OUTPUT
          
          # Log summary
          echo "üìä Secret Availability Summary:"
          echo "   OPENAI_API_KEY: $OPENAI_AVAILABLE"
          echo "   ANTHROPIC_API_KEY: $ANTHROPIC_AVAILABLE"
          echo "   DISCORD_WEBHOOK_URL: $DISCORD_AVAILABLE"

      - name: Check daily budget
        id: budget
        run: |
          # Create budget tracking file if it doesn't exist
          mkdir -p .github/automation
          BUDGET_FILE=".github/automation/budget-$(date +%Y-%m-%d).json"
          
          if [ ! -f "$BUDGET_FILE" ]; then
            echo '{"date":"'$(date +%Y-%m-%d)'","spent":0,"limit":25,"tasks":[]}' > "$BUDGET_FILE"
          fi
          
          SPENT=$(jq -r '.spent' "$BUDGET_FILE")
          LIMIT=$(jq -r '.limit' "$BUDGET_FILE")
          REMAINING=$(echo "$LIMIT - $SPENT" | bc)
          
          echo "spent=$SPENT" >> $GITHUB_OUTPUT
          echo "remaining=$REMAINING" >> $GITHUB_OUTPUT
          echo "limit=$LIMIT" >> $GITHUB_OUTPUT
          
          echo "üí∞ Budget Status: \$$SPENT / \$$LIMIT spent today (\$$REMAINING remaining)"
          
          # Check if budget is exhausted (unless forced)
          if [ "${{ github.event.inputs.force_assign }}" != "true" ] && (( $(echo "$REMAINING <= 0" | bc -l) )); then
            echo "‚ùå Daily budget exhausted. Skipping task assignment."
            echo "exhausted=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "exhausted=false" >> $GITHUB_OUTPUT

      - name: Discover tasks from documentation
        id: discover
        if: steps.budget.outputs.exhausted != 'true'
        run: |
          echo "üîç Discovering tasks from documentation files..."
          
          # Scan docs/ for task definitions (placeholder for future implementation)
          # This would parse docs/*.md files looking for task metadata
          # Format: <!-- TASK: id=xxx, priority=xxx, category=xxx -->
          
          if [ -d "docs" ]; then
            TASK_DOCS=$(find docs -name "*.md" -type f | wc -l)
            echo "üìÑ Found $TASK_DOCS documentation files"
            echo "   (Advanced task discovery from docs will be implemented in future iteration)"
          fi
          
          # Scan for tasks in PR comments (placeholder for future implementation)
          # This would use GitHub API to find task definitions in PR comments
          echo "   (PR comment task discovery will be implemented in future iteration)"
          
          echo "discovery_complete=true" >> $GITHUB_OUTPUT

      - name: Assign highest priority tasks
        id: assign
        if: steps.budget.outputs.exhausted != 'true' && steps.discover.outputs.discovery_complete == 'true'
        run: |
          # Read task registry
          REGISTRY="TASK_REGISTRY.json"
          
          echo "üìã Reading task registry from $REGISTRY"
          
          # Get ready tasks sorted by priority
          READY_TASKS=$(jq -c '[.tasks[] | select(.status == "ready")] | sort_by(-.priority, -.points)' "$REGISTRY")
          
          # Check for tasks with satisfied dependencies (simplified - only checking for empty dependencies array)
          ASSIGNABLE_TASKS=$(echo "$READY_TASKS" | jq -c '[.[] | select(.dependencies | length == 0)]')
          
          # Select up to 1 task based on remaining budget (single-task mode for 100% stability)
          # To enable multi-task mode: change "< 1" to "< 3" below
          REMAINING=${{ steps.budget.outputs.remaining }}
          
          # Use jq to build the selection (avoiding subshell issues)
          SELECTED_TASKS=$(echo "$ASSIGNABLE_TASKS" | jq -c --argjson remaining "$REMAINING" '
            reduce .[] as $task (
              {tasks: [], total: 0};
              if (.tasks | length) < 1 then
                (($task.estimatedMinutes // 0) * 0.008 / 60) as $cost |
                if (.total + $cost) <= $remaining then
                  {tasks: (.tasks + [$task]), total: (.total + $cost)}
                else
                  .
                end
              else
                .
              end
            ) | .tasks
          ')
          
          # Calculate final cost for display
          TOTAL_ESTIMATED=$(echo "$SELECTED_TASKS" | jq '[.[] | ((.estimatedMinutes // 0) * 0.008 / 60)] | add // 0')
          
          # Output selected tasks
          echo "tasks<<EOF" >> $GITHUB_OUTPUT
          echo "$SELECTED_TASKS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          TASK_COUNT=$(echo "$SELECTED_TASKS" | jq 'length')
          echo "üìã Assigned $TASK_COUNT task(s) with estimated cost: \$$TOTAL_ESTIMATED"

      - name: Trigger worker workflows
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TASKS='${{ steps.assign.outputs.tasks }}'
          
          # Configuration: delay between tasks in multi-task mode (seconds)
          INTER_TASK_DELAY=20
          
          # Initialize temp file to track successfully dispatched tasks
          rm -f /tmp/successfully_dispatched_tasks.txt
          touch /tmp/successfully_dispatched_tasks.txt
          
          # Function to trigger workflow with retry logic
          trigger_workflow_with_retry() {
            local workflow="$1"
            local task_id="$2"
            local task_json="$3"
            local max_retries=3
            local retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              echo "üì° Attempt $((retry_count + 1))/$max_retries for $task_id"
              
              # Build the command based on parameters
              if [ -z "$task_json" ]; then
                # dataHardening tasks: only task_id
                if gh workflow run "$workflow" -f task_id="$task_id" 2>&1; then
                  echo "‚úÖ Successfully triggered workflow for $task_id"
                  return 0
                else
                  local exit_code=$?
                  echo "‚ö†Ô∏è Dispatch failed with exit code $exit_code"
                fi
              else
                # Other tasks: task_id and task_json
                if gh workflow run "$workflow" \
                  -f task_id="$task_id" \
                  -f task_json="$task_json" 2>&1; then
                  echo "‚úÖ Successfully triggered workflow for $task_id"
                  return 0
                else
                  local exit_code=$?
                  echo "‚ö†Ô∏è Dispatch failed with exit code $exit_code"
                fi
              fi
              
              retry_count=$((retry_count + 1))
              
              if [ $retry_count -lt $max_retries ]; then
                # Linear backoff: 10s, 20s, 30s
                local delay=$((retry_count * 10))
                echo "‚è≥ Waiting ${delay}s before retry..."
                sleep $delay
              fi
            done
            
            echo "‚ùå Failed to trigger workflow for $task_id after $max_retries attempts"
            return 1
          }
          
          # Process each task sequentially with delays
          TASK_NUM=0
          while IFS= read -r task; do
            TASK_ID=$(echo "$task" | jq -r '.id')
            TASK_NAME=$(echo "$task" | jq -r '.name')
            TASK_CATEGORY=$(echo "$task" | jq -r '.category')
            
            # Add delay between tasks for multi-task mode stability
            # Skip delay for the first task
            if [ $TASK_NUM -gt 0 ]; then
              echo "‚è≥ Waiting ${INTER_TASK_DELAY}s before triggering next worker (rate limit protection)..."
              sleep $INTER_TASK_DELAY
            fi
            TASK_NUM=$((TASK_NUM + 1))
            
            echo "üöÄ Triggering worker for task: $TASK_ID - $TASK_NAME (Category: $TASK_CATEGORY)"
            
            # Determine which worker workflow to use based on category
            WORKFLOW="01-worker-executor.yml"
            case "$TASK_CATEGORY" in
              "waveA"|"corePlatform"|"features")
                WORKFLOW="01-worker-executor.yml"
                ;;
              "documentation")
                WORKFLOW="05-worker-documentation.yml"
                ;;
              "dataHardening")
                WORKFLOW="06-worker-testing.yml"
                ;;
            esac
            
            # Trigger the workflow with retry logic
            if [ "$TASK_CATEGORY" = "dataHardening" ] || [ "$TASK_CATEGORY" = "documentation" ]; then
              # 06-worker-testing.yml and 05-worker-documentation.yml only accept task_id (not task_json)
              if trigger_workflow_with_retry "$WORKFLOW" "$TASK_ID" ""; then
                echo "$TASK_ID" >> /tmp/successfully_dispatched_tasks.txt
                echo "--- Task $TASK_ID processing complete ---"
              else
                echo "--- Task $TASK_ID dispatch failed after retries ---"
              fi
            else
              # Other workflows accept task_id and task_json
              TASK_JSON=$(echo "$task" | jq -c .)
              if trigger_workflow_with_retry "$WORKFLOW" "$TASK_ID" "$TASK_JSON"; then
                echo "$TASK_ID" >> /tmp/successfully_dispatched_tasks.txt
                echo "--- Task $TASK_ID processing complete ---"
              else
                echo "--- Task $TASK_ID dispatch failed after retries ---"
              fi
            fi
          done < <(echo "$TASKS" | jq -c '.[]')

      - name: Track failed task dispatches
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != ''
        run: |
          # Create automation directory if it doesn't exist
          mkdir -p .github/automation
          FAILED_TASKS_FILE=".github/automation/FAILED_TASKS.json"
          
          # Initialize failed tasks file if it doesn't exist
          if [ ! -f "$FAILED_TASKS_FILE" ]; then
            echo '{"tasks":[],"lastUpdated":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > "$FAILED_TASKS_FILE"
          fi
          
          # Get list of all attempted tasks
          TASKS='${{ steps.assign.outputs.tasks }}'
          ALL_TASK_IDS=$(echo "$TASKS" | jq -r '.[].id')
          
          # Get list of successfully dispatched tasks
          DISPATCHED_IDS=""
          if [ -f /tmp/successfully_dispatched_tasks.txt ]; then
            DISPATCHED_IDS=$(cat /tmp/successfully_dispatched_tasks.txt || echo "")
          fi
          
          # Find tasks that failed to dispatch
          echo "üîç Checking for failed dispatches..."
          for TASK_ID in $ALL_TASK_IDS; do
            if ! echo "$DISPATCHED_IDS" | grep -q "^${TASK_ID}$"; then
              echo "‚ùå Task $TASK_ID failed to dispatch"
              
              # Get task details
              TASK_DATA=$(echo "$TASKS" | jq -c ".[] | select(.id == \"$TASK_ID\")")
              
              # Check if task already in failed tasks file
              EXISTING_COUNT=$(jq --arg id "$TASK_ID" '[.tasks[] | select(.id == $id)] | length' "$FAILED_TASKS_FILE")
              
              if [ "$EXISTING_COUNT" -eq 0 ]; then
                # Add new failed task with attempt count
                TMP_FILE=$(mktemp)
                jq --argjson task "$TASK_DATA" \
                   --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                   '.tasks += [($task + {failedAttempts: 1, lastAttempt: $timestamp})] | .lastUpdated = $timestamp' \
                   "$FAILED_TASKS_FILE" > "$TMP_FILE"
                mv "$TMP_FILE" "$FAILED_TASKS_FILE"
              else
                # Increment attempt count for existing failed task
                TMP_FILE=$(mktemp)
                jq --arg id "$TASK_ID" \
                   --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                   '.tasks |= map(if .id == $id then .failedAttempts += 1 | .lastAttempt = $timestamp else . end) | .lastUpdated = $timestamp' \
                   "$FAILED_TASKS_FILE" > "$TMP_FILE"
                mv "$TMP_FILE" "$FAILED_TASKS_FILE"
              fi
            else
              # Task succeeded - remove from failed tasks if present
              TMP_FILE=$(mktemp)
              jq --arg id "$TASK_ID" \
                 --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                 '.tasks |= map(select(.id != $id)) | .lastUpdated = $timestamp' \
                 "$FAILED_TASKS_FILE" > "$TMP_FILE"
              mv "$TMP_FILE" "$FAILED_TASKS_FILE"
            fi
          done
          
          # Log failed tasks summary
          FAILED_COUNT=$(jq '.tasks | length' "$FAILED_TASKS_FILE")
          echo "üìä Failed tasks tracking: $FAILED_COUNT task(s) in failed state"
          
          # Mark tasks with >3 failures as requiring review, >5 as abandoned
          if [ "$FAILED_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è Tasks with failed dispatch attempts:"
            jq -r '.tasks[] | "  - \(.id): \(.failedAttempts) attempt(s)"' "$FAILED_TASKS_FILE"
            
            # Check for tasks to review (>3 failures)
            REVIEW_COUNT=$(jq '[.tasks[] | select(.failedAttempts > 3 and .failedAttempts <= 5)] | length' "$FAILED_TASKS_FILE")
            if [ "$REVIEW_COUNT" -gt 0 ]; then
              echo "‚ö†Ô∏è Tasks with >3 failures (should be reviewed):"
              jq -r '.tasks[] | select(.failedAttempts > 3 and .failedAttempts <= 5) | "  - \(.id): \(.failedAttempts) attempts"' "$FAILED_TASKS_FILE"
            fi
            
            # Check for tasks to abandon (>5 failures - max retry limit)
            ABANDON_COUNT=$(jq '[.tasks[] | select(.failedAttempts > 5)] | length' "$FAILED_TASKS_FILE")
            if [ "$ABANDON_COUNT" -gt 0 ]; then
              echo "üö´ Tasks with >5 failures (max retry limit exceeded - ABANDONED):"
              jq -r '.tasks[] | select(.failedAttempts > 5) | "  - \(.id): \(.failedAttempts) attempts - REQUIRES MANUAL INTERVENTION"' "$FAILED_TASKS_FILE"
            fi
          fi
          
          # Commit failed tasks file
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase false
          git pull origin master || echo "‚ö†Ô∏è Pull failed - may result in conflicts during push"
          git add "$FAILED_TASKS_FILE"
          
          if ! git diff --staged --quiet; then
            git commit -m "chore: update failed tasks tracking"
            git push origin master || echo "‚ö†Ô∏è Failed to push failed tasks tracking - manual sync may be required"
          fi

      - name: Send Discord notification
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != '' && env.DISCORD_WEBHOOK_URL != ''
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          TASKS='${{ steps.assign.outputs.tasks }}'
          TASK_COUNT=$(echo "$TASKS" | jq 'length')
          BUDGET_REMAINING='${{ steps.budget.outputs.remaining }}'
          
          # Build task list for Discord
          TASK_LIST=$(echo "$TASKS" | jq -r '.[] | "‚Ä¢ **\(.id)** (\(.points) pts): \(.name)"' | awk '{printf "%s\\n", $0}')
          
          # Send Discord webhook
          curl -X POST "$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"ü§ñ Zakum Automation: Tasks Assigned\",
                \"description\": \"Assigned $TASK_COUNT task(s) for automated execution.\",
                \"color\": 3447003,
                \"fields\": [
                  {
                    \"name\": \"Tasks\",
                    \"value\": \"$TASK_LIST\"
                  },
                  {
                    \"name\": \"Budget Remaining\",
                    \"value\": \"\$$BUDGET_REMAINING / \$25.00\"
                  }
                ],
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" || echo "‚ö†Ô∏è Failed to send Discord notification"

      - name: Update task status
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != ''
        run: |
          REGISTRY="TASK_REGISTRY.json"
          
          # Check if any tasks were successfully dispatched
          if [ ! -f /tmp/successfully_dispatched_tasks.txt ]; then
            echo "‚ö†Ô∏è No tasks were successfully dispatched, skipping status update"
            exit 0
          fi
          
          # Read successfully dispatched task IDs
          DISPATCHED_IDS=$(cat /tmp/successfully_dispatched_tasks.txt | jq -R . | jq -s .)
          DISPATCHED_COUNT=$(echo "$DISPATCHED_IDS" | jq 'length')
          
          if [ "$DISPATCHED_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è No tasks were successfully dispatched, skipping status update"
            exit 0
          fi
          
          echo "üìù Updating status for $DISPATCHED_COUNT successfully dispatched task(s)"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase false
          
          # Pull latest changes first to minimize conflicts
          git pull origin master || echo "Pull failed, continuing..."
          
          # Update task status to "assigned" only for successfully dispatched tasks
          TMP_REGISTRY=$(mktemp)
          jq --argjson task_ids "$DISPATCHED_IDS" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             '.tasks |= map(
               if IN($task_ids[]; .id) then
                 .status = "assigned" | .assignedAt = $timestamp
               else
                 .
               end
             )' "$REGISTRY" > "$TMP_REGISTRY"
          
          mv "$TMP_REGISTRY" "$REGISTRY"
          
          # Stage changes
          git add "$REGISTRY"
          
          # Check if there are changes to commit
          if ! git diff --staged --quiet; then
            git commit -m "chore: assign tasks from orchestrator"
            
            # Try to push, retry with pull if needed
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push origin master; then
                echo "‚úÖ Successfully pushed changes"
                exit 0
              else
                echo "‚ö†Ô∏è Push failed, pulling and retrying... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
                
                # Pull with merge strategy
                if git pull origin master --no-edit; then
                  echo "Pulled latest changes, retrying push..."
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                else
                  echo "‚ùå Pull failed, there may be conflicts"
                  exit 1
                fi
              fi
            done
            
            echo "‚ùå Failed to push after $MAX_RETRIES attempts"
            exit 1
          fi

      - name: Summary
        run: |
          echo "## üéØ Orchestration Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Budget Status:** \$${{ steps.budget.outputs.spent }} / \$${{ steps.budget.outputs.limit }} spent" >> $GITHUB_STEP_SUMMARY
          echo "**Remaining:** \$${{ steps.budget.outputs.remaining }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.budget.outputs.exhausted }}" == "true" ]; then
            echo "‚ùå Daily budget exhausted. No tasks assigned." >> $GITHUB_STEP_SUMMARY
          else
            TASKS='${{ steps.assign.outputs.tasks }}'
            TASK_COUNT=$(echo "$TASKS" | jq 'length')
            echo "**Tasks Assigned:** $TASK_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$TASKS" | jq -r '.[] | "- **\(.id)** (\(.points) pts): \(.name)"' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check for more ready tasks (seamless looping)
        id: check_next
        if: steps.budget.outputs.exhausted != 'true'
        run: |
          REGISTRY="TASK_REGISTRY.json"
          
          # Pull latest changes to ensure we have the most recent task status
          git pull origin master --no-edit || echo "Pull failed, using local state"
          
          # Count ready tasks with no dependencies
          READY_COUNT=$(jq '[.tasks[] | select(.status == "ready" and (.dependencies | length == 0))] | length' "$REGISTRY")
          
          echo "üìä Ready tasks available: $READY_COUNT"
          echo "ready_count=$READY_COUNT" >> $GITHUB_OUTPUT
          
          # Check if budget allows for more tasks
          REMAINING=${{ steps.budget.outputs.remaining }}
          if (( $(echo "$REMAINING > 0" | bc -l) )) && [ "$READY_COUNT" -gt 0 ]; then
            echo "‚úÖ More tasks available and budget allows - will trigger next cycle"
            echo "trigger_next=true" >> $GITHUB_OUTPUT
          else
            if [ "$READY_COUNT" -eq 0 ]; then
              echo "üéâ All tasks completed! No more ready tasks."
              echo "üí´ System will restart from highest priority when new tasks become ready"
            else
              echo "üí∞ Budget exhausted - waiting for next budget cycle"
            fi
            echo "trigger_next=false" >> $GITHUB_OUTPUT
          fi

      - name: Trigger next cycle (24/7 continuous operation)
        if: steps.check_next.outputs.trigger_next == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üîÑ Triggering next orchestrator cycle for continuous operation..."
          
          # Wait a bit before triggering next cycle to avoid rate limits
          sleep 30
          
          # Trigger the manager orchestrator again
          if gh workflow run 00-manager-orchestrator.yml; then
            echo "‚úÖ Successfully triggered next cycle"
            echo "üîÅ 24/7 continuous loop active"
          else
            echo "‚ö†Ô∏è Failed to trigger next cycle - will resume on next scheduled run"
          fi
