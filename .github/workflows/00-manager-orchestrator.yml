name: "00 - Manager Orchestrator"

on:
  schedule:
    # Run every hour
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      force_assign:
        description: 'Force task assignment even if budget exhausted'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    outputs:
      tasks_assigned: ${{ steps.assign.outputs.tasks }}
      budget_remaining: ${{ steps.budget.outputs.remaining }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check daily budget
        id: budget
        run: |
          # Create budget tracking file if it doesn't exist
          mkdir -p .github/automation
          BUDGET_FILE=".github/automation/budget-$(date +%Y-%m-%d).json"
          
          if [ ! -f "$BUDGET_FILE" ]; then
            echo '{"date":"'$(date +%Y-%m-%d)'","spent":0,"limit":25,"tasks":[]}' > "$BUDGET_FILE"
          fi
          
          SPENT=$(jq -r '.spent' "$BUDGET_FILE")
          LIMIT=$(jq -r '.limit' "$BUDGET_FILE")
          REMAINING=$(echo "$LIMIT - $SPENT" | bc)
          
          echo "spent=$SPENT" >> $GITHUB_OUTPUT
          echo "remaining=$REMAINING" >> $GITHUB_OUTPUT
          echo "limit=$LIMIT" >> $GITHUB_OUTPUT
          
          echo "üí∞ Budget Status: \$$SPENT / \$$LIMIT spent today (\$$REMAINING remaining)"
          
          # Check if budget is exhausted (unless forced)
          if [ "${{ github.event.inputs.force_assign }}" != "true" ] && (( $(echo "$REMAINING <= 0" | bc -l) )); then
            echo "‚ùå Daily budget exhausted. Skipping task assignment."
            echo "exhausted=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "exhausted=false" >> $GITHUB_OUTPUT

      - name: Assign highest priority tasks
        id: assign
        if: steps.budget.outputs.exhausted != 'true'
        run: |
          # Read task registry
          REGISTRY="TASK_REGISTRY.json"
          
          # Get ready tasks sorted by priority
          READY_TASKS=$(jq -c '[.tasks[] | select(.status == "ready")] | sort_by(-.priority, -.points)' "$REGISTRY")
          
          # Check for tasks with satisfied dependencies (simplified - only checking for empty dependencies array)
          ASSIGNABLE_TASKS=$(echo "$READY_TASKS" | jq -c '[.[] | select(.dependencies | length == 0)]')
          
          # Select up to 3 tasks based on remaining budget
          REMAINING=${{ steps.budget.outputs.remaining }}
          
          # Use jq to build the selection (avoiding subshell issues)
          SELECTED_TASKS=$(echo "$ASSIGNABLE_TASKS" | jq -c --argjson remaining "$REMAINING" '
            reduce .[] as $task (
              {tasks: [], total: 0};
              if (.tasks | length) < 3 then
                (($task.estimatedMinutes // 0) * 0.008 / 60) as $cost |
                if (.total + $cost) <= $remaining then
                  {tasks: (.tasks + [$task]), total: (.total + $cost)}
                else
                  .
                end
              else
                .
              end
            ) | .tasks
          ')
          
          # Calculate final cost for display
          TOTAL_ESTIMATED=$(echo "$SELECTED_TASKS" | jq '[.[] | ((.estimatedMinutes // 0) * 0.008 / 60)] | add // 0')
          
          # Output selected tasks
          echo "tasks<<EOF" >> $GITHUB_OUTPUT
          echo "$SELECTED_TASKS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          TASK_COUNT=$(echo "$SELECTED_TASKS" | jq 'length')
          echo "üìã Assigned $TASK_COUNT task(s) with estimated cost: \$$TOTAL_ESTIMATED"

      - name: Trigger worker workflows
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TASKS='${{ steps.assign.outputs.tasks }}'
          
          # Initialize temp file to track successfully dispatched tasks
          rm -f /tmp/successfully_dispatched_tasks.txt
          touch /tmp/successfully_dispatched_tasks.txt
          
          while IFS= read -r task; do
            TASK_ID=$(echo "$task" | jq -r '.id')
            TASK_NAME=$(echo "$task" | jq -r '.name')
            TASK_CATEGORY=$(echo "$task" | jq -r '.category')
            
            echo "üöÄ Triggering worker for task: $TASK_ID - $TASK_NAME"
            
            # Determine which worker workflow to use based on category
            WORKFLOW="01-worker-executor.yml"
            case "$TASK_CATEGORY" in
              "waveA"|"corePlatform"|"features")
                WORKFLOW="01-worker-executor.yml"
                ;;
              "documentation")
                WORKFLOW="05-worker-documentation.yml"
                ;;
              "dataHardening")
                WORKFLOW="06-worker-testing.yml"
                ;;
            esac
            
            # Trigger the workflow with appropriate parameters
            if [ "$TASK_CATEGORY" = "dataHardening" ]; then
              # 06-worker-testing.yml only accepts task_id and test_scope (not task_json)
              if gh workflow run "$WORKFLOW" -f task_id="$TASK_ID"; then
                echo "‚úÖ Successfully triggered workflow for $TASK_ID"
                echo "$TASK_ID" >> /tmp/successfully_dispatched_tasks.txt
              else
                echo "‚ùå Failed to trigger workflow for $TASK_ID"
              fi
            else
              # Other workflows accept task_id and task_json
              if gh workflow run "$WORKFLOW" \
                -f task_id="$TASK_ID" \
                -f task_json="$(echo "$task" | jq -c .)"; then
                echo "‚úÖ Successfully triggered workflow for $TASK_ID"
                echo "$TASK_ID" >> /tmp/successfully_dispatched_tasks.txt
              else
                echo "‚ùå Failed to trigger workflow for $TASK_ID"
              fi
            fi
          done < <(echo "$TASKS" | jq -c '.[]')

      - name: Send Discord notification
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != '' && env.DISCORD_WEBHOOK_URL != ''
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          TASKS='${{ steps.assign.outputs.tasks }}'
          TASK_COUNT=$(echo "$TASKS" | jq 'length')
          BUDGET_REMAINING='${{ steps.budget.outputs.remaining }}'
          
          # Build task list for Discord
          TASK_LIST=$(echo "$TASKS" | jq -r '.[] | "‚Ä¢ **\(.id)** (\(.points) pts): \(.name)"' | awk '{printf "%s\\n", $0}')
          
          # Send Discord webhook
          curl -X POST "$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"ü§ñ Zakum Automation: Tasks Assigned\",
                \"description\": \"Assigned $TASK_COUNT task(s) for automated execution.\",
                \"color\": 3447003,
                \"fields\": [
                  {
                    \"name\": \"Tasks\",
                    \"value\": \"$TASK_LIST\"
                  },
                  {
                    \"name\": \"Budget Remaining\",
                    \"value\": \"\$$BUDGET_REMAINING / \$25.00\"
                  }
                ],
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" || echo "‚ö†Ô∏è Failed to send Discord notification"

      - name: Update task status
        if: steps.assign.outputs.tasks != '[]' && steps.assign.outputs.tasks != ''
        run: |
          REGISTRY="TASK_REGISTRY.json"
          
          # Check if any tasks were successfully dispatched
          if [ ! -f /tmp/successfully_dispatched_tasks.txt ]; then
            echo "‚ö†Ô∏è No tasks were successfully dispatched, skipping status update"
            exit 0
          fi
          
          # Read successfully dispatched task IDs
          DISPATCHED_IDS=$(cat /tmp/successfully_dispatched_tasks.txt | jq -R . | jq -s .)
          DISPATCHED_COUNT=$(echo "$DISPATCHED_IDS" | jq 'length')
          
          if [ "$DISPATCHED_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è No tasks were successfully dispatched, skipping status update"
            exit 0
          fi
          
          echo "üìù Updating status for $DISPATCHED_COUNT successfully dispatched task(s)"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase false
          
          # Pull latest changes first to minimize conflicts
          git pull origin master || echo "Pull failed, continuing..."
          
          # Update task status to "assigned" only for successfully dispatched tasks
          TMP_REGISTRY=$(mktemp)
          jq --argjson task_ids "$DISPATCHED_IDS" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             '.tasks |= map(
               if IN($task_ids[]; .id) then
                 .status = "assigned" | .assignedAt = $timestamp
               else
                 .
               end
             )' "$REGISTRY" > "$TMP_REGISTRY"
          
          mv "$TMP_REGISTRY" "$REGISTRY"
          
          # Stage changes
          git add "$REGISTRY"
          
          # Check if there are changes to commit
          if ! git diff --staged --quiet; then
            git commit -m "chore: assign tasks from orchestrator"
            
            # Try to push, retry with pull if needed
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push origin master; then
                echo "‚úÖ Successfully pushed changes"
                exit 0
              else
                echo "‚ö†Ô∏è Push failed, pulling and retrying... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
                
                # Pull with merge strategy
                if git pull origin master --no-edit; then
                  echo "Pulled latest changes, retrying push..."
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                else
                  echo "‚ùå Pull failed, there may be conflicts"
                  exit 1
                fi
              fi
            done
            
            echo "‚ùå Failed to push after $MAX_RETRIES attempts"
            exit 1
          fi

      - name: Summary
        run: |
          echo "## üéØ Orchestration Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Budget Status:** \$${{ steps.budget.outputs.spent }} / \$${{ steps.budget.outputs.limit }} spent" >> $GITHUB_STEP_SUMMARY
          echo "**Remaining:** \$${{ steps.budget.outputs.remaining }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.budget.outputs.exhausted }}" == "true" ]; then
            echo "‚ùå Daily budget exhausted. No tasks assigned." >> $GITHUB_STEP_SUMMARY
          else
            TASKS='${{ steps.assign.outputs.tasks }}'
            TASK_COUNT=$(echo "$TASKS" | jq 'length')
            echo "**Tasks Assigned:** $TASK_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$TASKS" | jq -r '.[] | "- **\(.id)** (\(.points) pts): \(.name)"' >> $GITHUB_STEP_SUMMARY
          fi
